use std::str::FromStr;

/**
å¤æ•°ï¼šå®æ•°+è™šæ•°
å®æ•°ï¼šæœ‰ç†æ•°+æ— ç†æ•°
æœ‰ç†æ•°ï¼šæ•´æ•°+æœ‰é™å°æ•°+æ— é™å¾ªç¯å°æ•°
æ— ç†æ•°ï¼šæ— é™ä¸å¾ªç¯å°æ•°
æ•´æ•°ï¼š0+æ­£æ•°+è´Ÿæ•°
è™šæ•°ï¼š å¯¹è´Ÿæ•°å¼€å¹³æ–¹æ ¹å¾—åˆ°çš„æ•°æ˜¯è™šæ•°ï¼Œä¹Ÿå°±æ˜¯è¯´åè¿‡æ¥è™šæ•°çš„å¹³æ–¹è¿˜æ˜¯è´Ÿæ•°ã€‚
* ç¬¬ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åº¦

*/
///
///
///
fn main() {
    println!("åŸºæœ¬ç±»å‹");
    let big_val = std::i32::MAX;
    // let x=big_val+1;   //è¿™æ ·å†™ä¼šè¯§å¼‚
    let x = big_val.wrapping_add(1);
    println!("æº¢å‡ºä¹‹åçš„ç¿»è½¬å€¼{:?}", x);

    // ç±»å‹è½¬æ¢
    let v: f64 = 3.2;

    println!("f64å€¼{:?} ç±»å‹è½¬æ¢ä¸º {:?}", v, v as f32);
    println!("-1.01f64.floor={}", -1.01f64.ceil());
    println!("-1.01f64.floor={}", -1.01f64.floor());
    println!("å¸ƒå°”è½¬æ¢ä¸ºæ•´æ•°={}", false as i32);
    println!("å¸ƒå°”è½¬æ¢ä¸ºæ•´æ•°={}", true as u32);
}

///
/// Rustå¯ä»¥æ ¹æ®ç±»å‹æ¨æ–­å‡½æ•°å¤§éƒ¨åˆ†çš„å€¼ï¼Œå®è·µä¸­ï¼Œå¯¹äºæŸä¸ªå˜é‡æˆ–è¡¨è¾¾å¼é€šå¸¸åªæœ‰ä¸€ç§ç±»å‹çš„å€¼é€‚ç”¨ã€‚æ­¤æ—¶ï¼Œ
/// Rustå…è®¸æˆ‘ä»¬å¿½ç•¥å…¶ä»–å˜é‡çš„ç±»å‹å£°æ˜ã€‚å¦‚ä¸‹
///
fn build_vector() -> Vec<i16> {
    let mut v: Vec<i16> = Vec::<i16>::new();
    v.push(16i16);
    v.push(20i16);
    v
}

///
/// ç®€å†™ç‰ˆæœ¬ï¼Œå’Œä¸Šé¢çš„å‡½æ•°å®Œå…¨ç­‰ä»·ä¸”ç¼–è¯‘çš„æœºå™¨ç ä¹Ÿä¸€æ ·
///
fn build_vector_easy() -> Vec<i16> {
    let mut v = Vec::new();
    v.push(16);
    v.push(22);
    v
}


///
///
///
fn print_slice(n: &[f64]) {
    for item in n {
        println!("{}", item);
    }
}

#[test]
fn test_print_slice() {
    let n0: Vec<i32> = (0..9).collect();
    let v: Vec<f64> = vec![6.2, 3., 5.6, 7.9];
    // æŠŠæ•´ä¸ªå‘é‡çš„å¼•ç”¨ç»™äº†åˆ‡ç‰‡
    let sn: &[f64] = &v;
    print_slice(sn);

    // åªç»™éƒ¨åˆ†èŒƒå›´çš„å…ƒç´ å¼•ç”¨ç»™åˆ‡ç‰‡
    let sn2: &[f64] = &v[2..];
    print_slice(sn2);


    let arr: [f64; 6] = [2., 4.23, 8., 9., 10., 6.88];
    // æŠŠæ•´ä¸ªæ•°ç»„çš„å¼•ç”¨ç»™äº†åˆ‡ç‰‡
    let sarr: &[f64] = &arr;
    print_slice(sarr);

    // åªç»™éƒ¨åˆ†èŒƒå›´çš„å…ƒç´ å¼•ç”¨ç»™åˆ‡ç‰‡
    let sarr2: &[f64] = &arr[1..6];
    print_slice(sarr2);

    let mut v_capacity: Vec<u32> = Vec::with_capacity(5);
    v_capacity.push(2);
    v_capacity.push(5);
    v_capacity.push(6);
    v_capacity.push(8);
    v_capacity.push(8);
    v_capacity.push(8);

    println!("å¯å®¹çº³æ•°é‡={}", v_capacity.capacity());
    println!("å®é™…æ•°é‡={}", v_capacity.len());
}

///
/// å­—ç¬¦ä¸²å­—é¢é‡ï¼ŒåŒå¼•å·éœ€è¦è½¬ä¹‰,  å­—ç¬¦ä¸²å¯ä»¥åˆ†æ•£åˆ°å¤šè¡Œ..
/// å¤šè¡Œå­—ç¬¦ä¸²å¸¦å·¦æ–œæ æ‹¼æ¥ï¼Œç±»ä¼¼äºjavaä¸­çš„ + å·ï¼Œå®é™…å­—ç¬¦ä¸²æ˜¯è¿ç€ä¸€èµ·çš„ï¼Œåªæ˜¯ä¸ºäº†å¯è¯»æ€§åˆ†åœ¨å¤šè¡Œå±•ç¤ºã€‚
///
/// Rustæä¾›äº† åŸå§‹å­—ç¬¦ä¸² è¯­æ³•ï¼ŒåŸå§‹å­—ç¬¦ä¸²é‡Œé¢çš„ä»»ä½•å†…å®¹éƒ½æŒ‰ç…§åŸæ ·ä¿å­˜ï¼Œä¸åšè½¬ä¹‰ã€‚
///
fn string() {
    let mut speech = "everything can be possible";
    println!("{}", speech);
    speech = "i can say:\"everything can be possible!\" ";
    println!("{}", speech);

    speech = "in the room come and go,\
    Singging of mount abora";
    println!("{}", speech);

    speech = "in the room come and go,
    Singging of mount abora";
    println!("raw_str={}", speech);

    // åŸå§‹å­—ç¬¦ä¸², r###"[è¿™é‡Œçš„å†…å®¹æ˜¯åŸå§‹å­—ç¬¦ä¸²æ–‡æœ¬]"###
    let raw_str = r###"i can say:"everything can be possible!\\" Singing of mount ab###ora "###;
    println!("{}", raw_str);
}

#[test]
fn test_string() {
    string();
}

///
/// å­—èŠ‚å­—ç¬¦ä¸² ï¼šå°±æ˜¯å‰ç¼€å¸¦b çš„å­—ç¬¦ä¸²å­—é¢é‡ã€‚å­—èŠ‚å­—ç¬¦ä¸² æ˜¯ u8ï¼ˆå³å­—èŠ‚ï¼‰ å€¼çš„åˆ‡ç‰‡ï¼Œ
/// ä¸æ˜¯unicodeæ–‡æœ¬çš„åˆ‡ç‰‡. å­—èŠ‚å­—ç¬¦ä¸²ä¸èƒ½åŒ…å«ä»»æ„unicodeå­—ç¬¦ï¼Œåªèƒ½æ˜¯ ascii å’Œ\xHH è½¬ç§»åºåˆ—
///
/// å­—ç¬¦ä¸²å­—é¢é‡çš„å€¼å­˜åœ¨å †å†…å­˜ï¼Œå­—ç¬¦ä¸²æœ¬èº«æœ‰3ä¸ªå¤´ä¿¡æ¯(æŒ‡å‘å †å†…å­˜é‡Œé¢å­—é¢é‡ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å¼•ç”¨åœ°å€ï¼Œ
///     å­—ç¬¦ä¸²å®¹é‡ï¼Œå­—ç¬¦ä¸²å®é™…å­—ç¬¦å­—èŠ‚é•¿åº¦)å­˜å‚¨åœ¨æ ˆå†…å­˜ã€‚
///
///  &str  ï¼Œå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå¯¹å…¶ä»–utf8æ–‡æœ¬æŸéƒ¨åˆ†å­—ç¬¦åºåˆ—çš„å¼•ç”¨ã€‚ä¹Ÿæ˜¯èƒ–æŒ‡é’ˆï¼Œ
/// æœ‰ä¸¤ä¸ªå¤´ä¿¡æ¯(å‘å †å†…å­˜é‡Œé¢å­—é¢é‡ç¬¬ä¸€ä¸ªå­—ç¬¦çš„å¼•ç”¨åœ°å€ï¼Œå¼•ç”¨éƒ¨åˆ†å®é™…å­—ç¬¦çš„å­—èŠ‚é•¿åº¦)å­˜å‚¨åœ¨æ ˆå†…å­˜ï¼Œ
///
/// String &str çš„len()æ–¹æ³•è¿”å›çš„æ˜¯å­—èŠ‚é•¿åº¦ï¼Œä¸æ˜¯å­—ç¬¦ä¸ªæ•°ã€‚ ä¸è¦è¯•å›¾ä¿®æ”¹ &stræŒ‡å‘å¼•ç”¨çš„éƒ¨åˆ†å­—ç¬¦å€¼ï¼Œç¼–è¯‘ä¼šæŠ¥panic
///  &strç±»ä¼¼äº æ•°ç»„ã€å‘é‡åˆ‡é¢ &[T]ï¼Œ  Stringç±»ä¼¼äº Vec<T>
///
fn byte_str() {
    let method = b"GET";
    println!("methond={:?}", method);
    assert_eq!(method, &[b'G', b'E', b'T']);

    let noodles = "noodles".to_string();
    let oodles = &noodles[1..];
    let poodles = "(ï¿£.ï¿£)";

    println!("å­—èŠ‚é•¿åº¦={:?}", noodles.len());
    println!("å­—èŠ‚é•¿åº¦={}", oodles.len());
    println!("å­—ç¬¦é•¿åº¦={}", poodles.chars().count());
    println!("å­—èŠ‚é•¿åº¦={}", poodles.len());

    // è¯•å›¾ä¿®å¤ å­—ç¬¦ä¸²åˆ‡ç‰‡ ä¸‹æ ‡0 çš„å€¼ï¼Œä¼šç¼–è¯‘Panic
    let mut s = "hello";
    // s[0] = 'A';
    // s.push('x');

    // ä»¥ä¸‹æ–¹å¼å¯ä»¥åˆ›å»ºå­—ç¬¦ä¸²
    let hello = "hello".to_string(); // å®é™…ä¸Šæ˜¯å¤åˆ¶å­—ç¬¦ä¸²
    // format!()å® å’Œ println!ç±»å‹ï¼ŒåŒºåˆ«æ˜¯ä»–è¿”å›ä¸€ä¸ªæ–°String,è€Œä¸æ˜¯ç›´æ¥æŠŠæ–‡æœ¬æ ‡å‡†è¾“å‡ºï¼Œå¹¶ä¸”ä¸ä¼šè‡ªåŠ¨åœ¨æœ«å°¾åŠ æ¢è¡Œç¬¦
    let longitude = format!("{}Â°{:02}'{:02}\"N", 24, 5, 23);
    println!("{}", longitude);

    // å­—ç¬¦ä¸²æ•°ç»„,
    let bits = vec!["veni", "bidi", "john"];
    println!("{}", bits.concat());
    println!("{}", bits.join("-"));

    // å­—ç¬¦ä¸²æ¯”è¾ƒã€‚æ”¯æŒ ==ï¼Œ !=,<, >,>=,<=  åªè¦å­—ç¬¦ä¸²åŒ…å«ç›¸åŒå­—ç¬¦ï¼Œé¡ºåºã€‚é‚£ä¹ˆå°±ç›¸ç­‰ï¼Œæ— è®ºä»–ä»¬æ˜¯å¦æŒ‡å‘ åŒä¸€ä¸ªå†…å­˜åœ°å€
    assert!("ONE".to_lowercase() == "one");
    println!("{}", "ç›¸å¯¹æ— è¨€ï¼Œæ¬²è¯­æ³ªåƒè¡Œ".contains("æ³ª"));
    println!("{}", "ç›¸å¯¹æ— è¨€ï¼Œ(ï¿£.ï¿£)".replace("ï¿£", "ğŸŒ"));
    println!("{}", "ç›¸å¯¹æ— è¨€ï¼Œ(ï¿£.ï¿£)\n");
    println!("{}", "ç›¸å¯¹æ— è¨€ï¼Œ(ï¿£.ï¿£)   ".trim());

    let word_comma = "å¤œï¼Œæ¥ï¼Œå¹½ï¼Œæ¢¦ï¼Œå¿½ï¼Œè¿˜ï¼Œä¹¡";
    let split = word_comma.split("ï¼Œ");
    for word in split {
        println!("{}", word);
    }

}

#[test]
fn test_byte_string() {
    byte_str();
}
